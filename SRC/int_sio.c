/****************************************************************************

    sio.c - простейший драйвер последовательного канала
            для учебного стенда SDK-1.1

    (C) sio.c, Ключев А.О.  2007 г.

Это свободная программа; вы можете повторно распространять ее и/или
модифицировать ее в соответствии с Универсальной Общественной
Лицензией GNU, опубликованной Фондом Свободного ПО; либо версии 2,
либо (по вашему выбору) любой более поздней версии.

Эта программа распространяется в надежде, что она будет полезной,
но БЕЗ КАКИХ-ЛИБО ГАРАНТИЙ; даже без подразумеваемых гарантий
КОММЕРЧЕСКОЙ ЦЕННОСТИ или ПРИГОДНОСТИ ДЛЯ КОНКРЕТНОЙ ЦЕЛИ.  Для
получения подробных сведений смотрите Универсальную Общественную
Лицензию GNU.

Вы должны были получить копию Универсальной Общественной Лицензии
GNU вместе с этой программой; если нет, напишите по адресу: Free
Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
02111-1307 USA

----------------------------------------------------------------------------
Россия, Санкт-Петербург, кафедра вычислительной техники СПбГУИТМО 
e-mail: kluchev@d1.ifmo.ru

****************************************************************************/
#include "aduc812.h"
#include "int_sio.h"
#include "fifo.h"
#include "led.h"

static fifo_t rFifo;
static fifo_t wFifo;

void SIO_ISR( void ) __interrupt ( 4 ) {
    if(TI) {
        // Передача байта
        // Читаем WFIFO (буфер передачи) и записываем его в SBUF
        SBUF = pullElement(&wFifo);
        TI = 0;
    }
    if(RI) {
        // Прием байта
        // Читаем SBUF и записываем его в RFIFO (буфер приема)
        pushElement(&rFifo, SBUF);
        RI = 0;
    }
}

void SetVector(unsigned char __xdata * Address, void * Vector)
{
	unsigned char __xdata * TmpVector; // Временная переменная

	// Первым байтом по указанному адресу записывается 
	// код команды передачи управления ljmp, равный 02h
	*Address = 0x02;
	// Далее записывается адрес перехода Vector
	TmpVector = (unsigned char __xdata *) (Address + 1);
	*TmpVector = (unsigned char) ((unsigned short)Vector >> 8);
	++TmpVector;
	*TmpVector = (unsigned char) Vector;
	// Таким образом, по адресу Address теперь
	// располагается инструкция ljmp Vector
}


/**----------------------------------------------------------------------------
                        init_sio()
-------------------------------------------------------------------------------
Инициализирует последовательный канал на заданной скорости. Использует таймер 1

Вход:       char speed - скорость. Задается константами, описанными в 
                заголовочном файле sio.h
            bit sdouble - дублирование скорости: 0 - не дублировать скорость,
                заданную аргументом speed; 1 - дублировать.
Выход:      нет
Результат:  нет
----------------------------------------------------------------------------- */
void init_sio( unsigned char speed )
{
    initFifo(&rFifo);
    initFifo(&wFifo);
    
    SetVector( 0x23, (void *)SIO_ISR );
    
    TH1       =  speed; 
    TMOD     |=  0x20; //Таймер 1 будет работать в режиме autoreload
    TCON     |=  0x40; //Запуск таймера 1
    SCON      =  0x50; //Настройки последовательного канала
    ES        =  1;    // Enable serial interrupt
    EA        =  1;     // Enable any interrupt
}

/**----------------------------------------------------------------------------
                        RSioStat()
-------------------------------------------------------------------------------
Возвращает ненулевое значение, если буфер приема не пуст

Вход:       нет
Выход:      нет
Результат:  0 - буфер приема пуст;
            1 - был принят символ
----------------------------------------------------------------------------- */
unsigned char rsiostat(void)  
{
    return RI;
}


/**----------------------------------------------------------------------------
                        wsio
-------------------------------------------------------------------------------
Отправляет символ по последовательному каналу

Вход:       unsigned char c - символ, который нужно отправить
Выход:      нет
Результат:  нет
----------------------------------------------------------------------------- */
void wsio( unsigned char c )
{
    char oldES = ES;
    int fifoWasEmpty;
    ES = 0;
    
    fifoWasEmpty = isEmpty(&wFifo);
    pushElement(&wFifo, c);
    
    if (fifoWasEmpty) {
        TI = 1;
    }
    
    ES = oldES;
}

/**----------------------------------------------------------------------------
                        rsio()
-------------------------------------------------------------------------------
Дожидается приема символа из последовательного канала и возвращает его.

Вход:       нет
Выход:      нет
Результат:  принятый символ
----------------------------------------------------------------------------- */
unsigned char rsio(void)
{
    unsigned char c;
    char oldES = ES;
    
    ES = 0;
    
    if (isEmpty(&rFifo)) {
        c = 0;
    }
    else {
        c = pullElement(&rFifo);
    }
    
    ES = oldES;
    return c;
}


/**----------------------------------------------------------------------------
                        type()
-------------------------------------------------------------------------------
Выводит ASCIIZ-строку в последовательный канал

Вход:       char *str - указатель на строку
Выход:      нет
Результат:  нет
----------------------------------------------------------------------------- */
void type(char * str)
{
    while( *str ) wsio( *str++ );
}

