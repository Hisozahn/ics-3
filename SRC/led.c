/****************************************************************************

    led.c - простейший драйвер светодиодов
            для учебного стенда SDK-1.1

    (C) led.c, Ключев А.О.  2007 г.

Это свободная программа; вы можете повторно распространять ее и/или
модифицировать ее в соответствии с Универсальной Общественной
Лицензией GNU, опубликованной Фондом Свободного ПО; либо версии 2,
либо (по вашему выбору) любой более поздней версии.

Эта программа распространяется в надежде, что она будет полезной,
но БЕЗ КАКИХ-ЛИБО ГАРАНТИЙ; даже без подразумеваемых гарантий
КОММЕРЧЕСКОЙ ЦЕННОСТИ или ПРИГОДНОСТИ ДЛЯ КОНКРЕТНОЙ ЦЕЛИ.  Для
получения подробных сведений смотрите Универсальную Общественную
Лицензию GNU.

Вы должны были получить копию Универсальной Общественной Лицензии
GNU вместе с этой программой; если нет, напишите по адресу: Free
Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
02111-1307 USA

----------------------------------------------------------------------------
Россия, Санкт-Петербург, кафедра вычислительной техники СПбГУИТМО 
e-mail: kluchev@d1.ifmo.ru

****************************************************************************/

#include "aduc812.h"
#include "max.h"
#include "led.h"
#include <string.h>

static unsigned char old_led = 0;   // "Видеопамять" линейки светодиодов


/**----------------------------------------------------------------------------
                            led
-------------------------------------------------------------------------------
Управление одним светодиодом

Вход:       n  - порядковый номер светодиода ( от 0 до 7 )
            on - 1 - зажигает, 0 гасит светодиод
Выход:      нет
Результат:  нет
Описание:   Производится доступ к регистру расширителя портов SV с помощью
            функции write_max. Состояние светодиодов хранится в регистре old_led.

Пример:
-----------------------------------------------------------------------------*/

void led( unsigned char n, unsigned char on )
{
unsigned char c;
unsigned char mask = 1;

    if( n > 7 ) return;

    c = old_led;

    mask <<= n;

    if( on )
        c |= mask;
    else
        c &= ~mask;         

    write_max( SV, c );     

    old_led = c;
}


/**----------------------------------------------------------------------------
                            leds
-------------------------------------------------------------------------------
Зажигание линейки светодиодов

Вход:       on - управление светодиодами. Каждый бит переменной отвечает за один 
            светодиод: 1 - зажигает, 0 гасит светодиод
Выход:      нет
Результат:  нет
Описание:   Производится доступ к регистру расширителя портов SV с помощью
            функции write_max. Состояние светодиодов хранится в регистре old_led.

Пример:
-----------------------------------------------------------------------------*/

void leds( unsigned char on )
{
    write_max( SV, on );     

    old_led = on;
}

//////////////////////// WriteLED ///////////////////////////
// Функция установки состояния линейки светодиодов.
// Вход:
// value – состояния светодиодов.
// Выход: нет.
// Результат: нет.
//////////////////////////////////////////////////////////////
void WriteLED(unsigned char value)
{
	// Запись состояния светодиодов в регистр 7-й регистр ПЛИС
	write_max( 7, value );
}
//////////////////////// T0_ISR //////////////////////////////
// Обработчик прерывания от таймера 0.
// Вход: нет.
// Выход: нет.
// Результат: нет.
//////////////////////////////////////////////////////////////
//unsigned int r = 0;
//unsigned char tick = 1;
unsigned char tick = 1;
unsigned char brightness[LED_COUNT] = {0, 0, 0, 0, 0, 0, 0, 0};
unsigned char leds_wait[LED_COUNT] = {0, 0, 0, 0, 0, 0, 0, 0};

/*void T0_ISR( void ) __interrupt ( 1 )
{	
	unsigned char i = 0;
	unsigned char led = 0;
	unsigned char mask = 1;	
	
	for (;i < LED_COUNT; i++) {		
		leds_wait[i] += brightness[i];
		if (leds_wait[i] >= 100) {
			leds_wait[i] -= 100;
			led += mask;
		}
		mask <<= 1;
	}
	leds(led);
	TH0 = 0xFF;
	TL0 = 0x30;
}*/

/*void T0_ISR( void ) __interrupt ( 1 )
{	
	unsigned char i = 0;
	unsigned char led = 0;
	unsigned char mask = 1;	
	
	if (tick > 50) {
		tick = 1;
	}
	for (; i < LED_COUNT; i++) {		
		if (tick < brightness[i]/2) {			
			led += mask;
		}
		mask <<= 1;
	}
	tick++;
	leds(led);
	TH0 = 0xFF;
	TL0 = 0xF0;
}*/

void SetBrightness(unsigned char ledId, unsigned char b) {
	if (b > 100) {
		return;
	}
	
	if (ledId > LED_COUNT - 1) {
		return;
	}
	
	brightness[ledId] = b;
}

void SetBrightnesses(const unsigned char* brigthness_v) {
    char old_ET0 = ET0;
	ET0 = 0;
	memcpy(brightness, brigthness_v, LED_COUNT);
	ET0 = old_ET0;
}



